---
title: 3.7 微服务敏捷开发解决方案
keywords: [ SCA ]
description: 微服务敏捷开发不简单安得环境千万套，大庇开发小哥俱欢笑微服务给大家带来了敏捷开发的特性，基于敏捷开发的带来的便利，让我们可以在同一个时间内多个迭代/feature 并行开发。但是，微服务架构本身也给开发环境带来了一定的复杂性：每个 feature 的修改点都可能会被分散在多个应用中，需要多个应...
---
<a name="Me0fy"></a>
## 微服务敏捷开发不简单
<a name="nxrCp"></a>
### 安得环境千万套，大庇开发小哥俱欢笑

微服务给大家带来了敏捷开发的特性，基于敏捷开发的带来的便利，让我们可以在同一个时间内多个迭代/feature 并行开发。但是，微服务架构本身也给开发环境带来了一定的复杂性：每个 feature 的修改点都可能会被分散在多个应用中，需要多个应用互相配合才能完成整体的逻辑。这些应用既需要互相配合好，又不能让他们互相影响，敏捷开发有时候也不是那么容易。

相信实践过微服务敏捷开发的同学都曾经遇到过以下情况：

1. 开发接口时，应用无法独立地联调测试，需要依赖于下游的返回，所以一般都需要一个完整的开发环境，这个环境需要包含所有的其他应用。
2. A 同学辛辛苦苦，终于开发好了一个接口，但是部署到开发环境后，发现返回值一直是错的，就是不符合预期，百思不得其解。最终根据日志、arthas 层层跟踪下去，发现原来是另一个同事更新了下游应用的代码，导致原有逻辑发生了变更。
3. A 同学准备开始联调测试了，这时候他要找到开发 B 和 C 吼一嗓子确认：**“我要开始测试了哈兄弟们，你们都别动环境，不要重启和 debug 哈”。**B 同学 和 C 同学一脸懵逼：**“我自己这还有个逻辑没理清楚呢，刚改完代码准备测一发，你这一测试联调我就不能动环境了，我这功能得等到什么时候才能开发好”**。
4. 排查问题好麻烦啊，要不直接 debug 一下吧，这 IDEA 远程 debug 刚连上去呢，立马就传来了同事的声音：**“谁 XX 又在瞎动环境啊，怎么刚刚还能跑的接口现在就出错了”。**



以上这些问题显然会影响项目的进度，非常容易造成项目延期**。对于此刻的开发小哥哥而言，拥有一套属于自己的独立环境，带来的幸福感也许比有一套属于自己的小房子还大。**

<a name="cDoUs"></a>
### 流量闭环是微服务敏捷开发的基础

上文中提到的问题，其实都是因为没有在开发环境中，精准地控制流量在 feature 环境内流转。

为什么精准地控制流量如此重要？举个最简单的微服务架构图来说明，这里假设应用的调用链路为 A ---> B ---> C ---> D ，现在同时开发两个 feature， feature1 和 feature2 。feature1 需要修改 A 和 C 的代码， feature2 需要修改 B、C 和 D 的代码。<br />为了方便表述，我们用 A、B、C、D 来代指 A、B、C、D 的线上稳定版本，也叫做基线版本；A1、C1 来代指 feature1 环境中的 A 和 C ；B2、C2、D2 来来代指 feature2 环境中 B、C、D。

那么开发测试 feature1 的同学会要求他的请求，准确地在 A1 ---> B ---> C1 ---> D 中流转。为什么一定要这样，我们来简单分析一下：

1. 如果流量走到 A 或者 C 的基线环境，因为他们都没有包含 feature1 相关的代码，所以肯定是无法正常测试和联调 feature1 对应的功能。
2. 如果流量走到 B2、D2 环境，大多数情况下是可以正常工作的，因为正常情况下 B2 和 D2 中的修改是不会影响 feature1 的。但是因为 feature1 和 feature2 可能是由不同的同学开发的，或者有不同的开发排期和节奏，他们有自己的开发、重启、debug 节奏，所以大概率还是会出现上文中提到的场景。

**综上所述，让流量在 feature 环境内流转非常重要，是微服务敏捷开发的基础。**

![](https://intranetproxy.alipay.com/skylark/lark/0/2021/jpeg/54319/1637206157269-299bc727-6e7b-4dc0-afe9-888a3e66bf54.jpeg)<br />![第七节_3-7-1 第三章第七节第一张图.png](https://intranetproxy.alipay.com/skylark/lark/0/2022/png/54319/1648211219207-799295fc-2e05-4ce7-8e9c-e33dd9937fd0.png#clientId=u2337d8a6-1db4-4&from=ui&id=uf99ba2c3&originHeight=277&originWidth=723&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11089&status=done&style=none&taskId=u7b159d2e-f857-440e-a859-7ac53e1c7c8&title=)

如何准确地让请求在 feature 环境内流转呢？最简单的办法是每个迭代/Feature 的都享有一套独立的完整环境，这套独立的环境包含了整个微服务应用集所有的应用，包含注册中心和接入层，这样就能确保流量在 feature 环境里闭环，不用担心应用之间互相影响。

![](https://intranetproxy.alipay.com/skylark/lark/0/2021/jpeg/54319/1637635157496-a1402a3b-e4e9-49ed-8277-b135a2681157.jpeg)<br />![第七节_3-7-2 第三章第七节第二张图.png](https://intranetproxy.alipay.com/skylark/lark/0/2022/png/54319/1648211231701-01d8ea5a-095e-449f-8360-c41dd1674a8a.png#clientId=u2337d8a6-1db4-4&from=ui&id=u3f249233&originHeight=316&originWidth=723&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14276&status=done&style=none&taskId=u6f46ca35-a4b2-4f4e-bbde-a65e477fabf&title=)

这个解决方案虽然简单，但是问题也很显而易见，成本比较大。我们假设微服务应用有10个，每个应用只部署一台，以 java 为例，部署一个 java 应用按  2C4G 的 共享标准型 ECS 进行计算，维护一套环境一年的成本是 10 × 140 × 12 = 16800元，**如果同时有4套环境，即只支持两个迭代并行开发，每个迭代只有2个feature，这样一年的成本就是 67200 元，而且我们可以发现，这里面计算公式使用的是乘法，当应用增加和环境增加时，成本的增加是成倍的。**

注意，这里只是单纯地计算了应用使用的 ECS 的成本，其他周边的配套设施我们还没有计算，因为我们的开发、联调、测试是需要确保端到端的全流程都是 OK 的，那这里就还会涉及到 域名/SLB/网关/注册中心这些资源，这些资源一般比较固定，不会需要进行大的修改，但是在多套环境的方案下这些资源也需要维护多套，成本还会进一步上升。

**那么，有没有一个比较优雅地方式，既能享受到微服务架构带来的敏捷开发的便利，又不会给日常开发环境的搭建带来很大的成本呢？ 基于 MSE 标签路由功能使用开发环境隔离方案是您的不二之选。**

<a name="xCEGK"></a>
### 如何低成本玩转敏捷开发

排除了物理环境隔离的方式之后，我们很自然地去想到，逻辑隔离。简单地说，表面上看起来有很多套环境，每个环境都有一套完整的微服务应用。但是这些环境内的有些应用节点不是只属于某一个环境的，是被多个环境共享的，这样就能减少很多机器的成本。理想中的逻辑隔离可以做到这样，只需要维护一套完整的基线环境，在增加 feature 环境时，只需要单独部署这个 feature 所涉及到改动的应用即可，而不需要在每个 feature 环境都部署整套的微服务应用及其配套设施。

我们称之这唯一的一套完整的环境为基线环境。基线环境包含了所有微服务应用，也包含了服务注册中心、域名、SLB、网关 等其他设施，而 feature 环境中只包含了这个 feature 中需要修改的应用。这样维护 n 套 feature 环境的成本，就变成了加法，而不是原来的乘法，由 n × m 变成了  n ＋  m。**差不多相当于零成本增加 feature 环境，这样我们就可以放心地扩容出多套 feature 环境，每个开发小哥哥都可以轻松拥有属于自己的独立环境，尽情地享受微服务敏捷开发。**

![](https://intranetproxy.alipay.com/skylark/lark/0/2021/jpeg/54319/1637220433966-6d7c039a-64ad-4b5b-b67d-74be064969c4.jpeg)<br />![第七节_3-7-3 第三章第七节第三张图.png](https://intranetproxy.alipay.com/skylark/lark/0/2022/png/54319/1648211257615-d884a655-045f-454c-b021-9602f8e93654.png#clientId=u2337d8a6-1db4-4&from=ui&id=ub7c2d949&originHeight=411&originWidth=723&originalType=binary&ratio=1&rotation=0&showTitle=false&size=27098&status=done&style=none&taskId=u0151ed74-e349-41a5-9ee8-6c23f34c16a&title=)<br />![架构图_4-6-1 第四章第六节第一张图.jpg](https://intranetproxy.alipay.com/skylark/lark/0/2022/jpeg/54319/1648211272029-ff9c24fd-cf5d-4a2f-bec8-e0300835d377.jpeg#clientId=u2337d8a6-1db4-4&from=ui&id=u8ae5fce1&originHeight=1844&originWidth=3308&originalType=binary&ratio=1&rotation=0&showTitle=false&size=265374&status=done&style=none&taskId=ud332dfd2-ddb4-4385-b567-12db126a6f5&title=)


从上图中我们可以看到，feature1 对应的流量，在发现 feature1 中存在 A1 应用时，一定会去往 A1 节点，A1在调用B的时候发现 feature1 环境中不存在 B1 ，则会将请求发到 基线版本的 B 中；B在调用C时，发现 feature1 环境存在 C1 应用，又会返回到 feature1 环境中，依次类推，确保了流量会在 feature1 环境中闭环。

逻辑隔离的方式确实比物理隔离强大了不少，但是实施起来的复杂度也高了很多。

从开源的角度来看，实现逻辑隔离有个比较通用的方式。 服务提供者将环境标相关的信息注册到注册中心里，于是消费者从注册中心中获取的服务提供者列表就包含了环境相关的信息。消费者在路由的过程中，对请求的内容进行计算，选择出与之对应的目标环境，最后再与服务提供者列表中的元数据信息进行匹配，找到正确的目标节点进行路由。<br />描述起来比较简单，但是这个过程中，也有一些需要注意的地方。

1. 在请求的链路中，调用中包含了参数千变万化，源头的 header 信息不一定能被带到下一跳，如何使得入口处配置好的规则，能够在整条链路都生效，这里是一个问题。
2. 逻辑隔离的过程中，会存在某个应用不存在 feature 环境的情况，如何在请求被降级到 base 环境后，能够重新回到feature 环境，这里需要借助于全链路流量透传去传递。
3. 微服务的版本比较多，需要对于不同的版本进行适配，同时保证在出现流量规则冲突时，有兜底的措施。

这一些逻辑实现起来还是有些困难，但是基本原理，都是类似的。

**当然也可以使用阿里云微服务引擎 MSE 提供的方案，开箱即用，在使用的过程中，您不需要修改任何代码和配置，直接接入 MSE 微服务治理即可使用，不会给您增加任何开发成本。**
